/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       John Schmidt                                              */
/*    Created:      Tue Dec 03 2019                                           */
/*    Description:  V5 project-PID                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
//
// PID Base Control
//

#include "vex.h"

using namespace vex;

vex::motor LeftFront         = vex::motor( vex::PORT11 );
vex::motor LeftBack          = vex::motor( vex::PORT20 );
vex::motor RightFront         = vex::motor( vex::PORT1 );
vex::motor RightBack         = vex::motor( vex::PORT10 );
vex::motor ArmMotor           = vex::motor( vex::PORT5 );
vex::motor TrayMotor          = vex::motor( vex::PORT6 );
vex::motor LeftIntake         = vex::motor( vex::PORT2 );
vex::motor RightIntake        = vex::motor( vex::PORT9 );

vex::controller Controller1          = vex::controller();

int DriverTray;
int DriverArm;
int DriverIntake;
int DriverDuration = 20;

int LeftError = 0;
int RightError = 0;
int ArmError = 0;
int TrayError = 0;
int IntakeError = 0;

int LeftIntegral = 0;
int RightIntegral = 0;
int ArmIntegral = 0;
int TrayIntegral = 0;
int IntakeIntegral = 0;

int LeftDeriv = 0;
int RightDeriv = 0;
int ArmDeriv = 0;
int TrayDeriv = 0;
int IntakeDeriv = 0;

int LeftLast;
int RightLast;
int ArmLast;
int TrayLast;
int IntakeLast;

int LeftLastTarget;
int RightLastTarget;
int ArmLastTarget;
int TrayLastTarget;
int IntakeLastTarget;


class PID 
{

  public:
  int Target;
  int Actual;
  int LastError;
  int LastTarget;
  int Error;
  int Integral;
  int Derivative;

  PID(int a, int b, int c, int d) {
    Target = a;
    Actual = b;
    LastError = c;
    LastTarget = d;
  }

  void update(){
    Error = Target - Actual; //Proportional Calculations

    if(abs(Target - LastTarget) < 5 ){
      Integral = Integral + Error; //Integral Calculations
    } else {
      Integral = 0; //Decays the integral value if the target values are different
    }

    Derivative = Error - LastError; //Derivative Calculations
  }

  void setTarget(int a){
    Target = a;
  }

};


void driveCode(int LeftTarget, int RightTarget, int ArmTarget, int TrayTarget, int IntakeTarget, int duration){
  
  //PID Calculations for the drive motors

  //Proportional Calculations:
  LeftError = LeftTarget - ((LeftFront.velocity(vex::velocityUnits::pct) + LeftBack.velocity(vex::velocityUnits::pct))/2);
  RightError = RightTarget - ((RightFront.velocity(vex::velocityUnits::pct) + RightBack.velocity(vex::velocityUnits::pct))/2);

  //Integral Calculations:
  if(abs(LeftTarget - LeftLastTarget) < 5 ){
    LeftIntegral = LeftIntegral + LeftError;
  } else {
    LeftIntegral = 0; //Decays the integral value if the target values are different
  }
  if(abs(RightTarget - RightLastTarget) < 5 ){
    RightIntegral = RightIntegral + RightError;
  } else {
    RightIntegral = 0; //Decays the integral value if the target values are different
  }

  //Derivative Calculations:
  LeftDeriv = LeftError - LeftLast;
  RightDeriv = RightError - RightLast;

  LeftFront.spin(vex::directionType::fwd, ((LeftTarget*( 0.6 )) + (LeftError * ( 0.2 )) + (LeftIntegral*( 0.8 )) + (LeftDeriv * ( 0.3 ))), vex::velocityUnits::pct);
  LeftBack.spin(vex::directionType::fwd, ((LeftTarget*( 0.6 )) + (LeftError * ( 0.2 )) + (LeftIntegral*( 0.8 )) + (LeftDeriv * ( 0.3 ))), vex::velocityUnits::pct);
  RightFront.spin(vex::directionType::fwd, ((RightTarget*( 0.6 )) + (RightError * ( 0.2 )) + (RightIntegral*( 0.8 )) + (RightDeriv * ( 0.3 ))), vex::velocityUnits::pct);
  RightBack.spin(vex::directionType::fwd, ((RightTarget*( 0.6 )) + (RightError * ( 0.2 )) + (RightIntegral*( 0.8 )) + (RightDeriv * ( 0.3 ))), vex::velocityUnits::pct);


  //PID Calculations for the Auxiliary functions- tray, arm, and intake

  //Proportional Calculations:
  ArmError = ArmTarget - (ArmMotor.velocity(vex::velocityUnits::pct));
  TrayError = TrayTarget - (TrayMotor.velocity(vex::velocityUnits::pct));
  IntakeError = IntakeTarget - ((LeftIntake.velocity(vex::velocityUnits::pct) + RightIntake.velocity(vex::velocityUnits::pct))/2);

  //Integral Calculations:
  if(ArmLastTarget == ArmTarget){
    ArmIntegral = ArmIntegral + ArmError;
  } else {
    ArmIntegral = 0; //Decays the integral value if the target values are different
  }

  if(TrayLastTarget == TrayTarget){
    TrayIntegral = TrayIntegral + TrayError;
  } else {
    TrayIntegral = 0; //Decays the integral value if the target values are different
  }

  if(IntakeLastTarget == IntakeTarget){
    IntakeIntegral = IntakeIntegral + IntakeError;
  } else {
    IntakeIntegral = 0; //Decays the integral value if the target values are different
  }

  //Derivative Calculations
  ArmDeriv = ArmError - ArmLast;
  TrayDeriv = TrayError - TrayLast;
  IntakeDeriv = IntakeError - IntakeLast;

  ArmMotor.spin(vex::directionType::fwd, ((ArmTarget*( 0.5 )) + (ArmError*( 0.8 )) + (ArmIntegral*( 0.1 )) + (ArmDeriv*( 0.3 ))), vex::velocityUnits::pct);
  TrayMotor.spin(vex::directionType::fwd, ((TrayTarget*( 0.5 )) + (TrayError*( 0.8 )) + (TrayIntegral*( 0.1 )) + (TrayDeriv*( 0.3 ))), vex::velocityUnits::pct);
  LeftIntake.spin(vex::directionType::fwd, ((IntakeTarget*( 0.5 )) + (IntakeError*( 0.8 )) + (IntakeIntegral*( 0.1 )) + (IntakeDeriv*( 0.3 ))), vex::velocityUnits::pct);
  RightIntake.spin(vex::directionType::fwd, ((IntakeTarget*( 0.5 )) + (IntakeError*( 0.8 )) + (IntakeIntegral*( 0.1 )) + (IntakeDeriv*( 0.3 ))), vex::velocityUnits::pct);


  //Saves the previous values of targets and errors
  RightLast = RightError;
  LeftLast = LeftError;
  ArmLast = ArmError;
  TrayLast = TrayError;
  IntakeLast = IntakeError;

  RightLastTarget = RightTarget;
  LeftLastTarget = LeftTarget;
  ArmLastTarget = ArmTarget;
  TrayLastTarget = TrayTarget;
  IntakeLastTarget = IntakeTarget;

  vex::task::sleep(duration);
}

int main() {
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();

  while(1){
    if(Controller1.ButtonA.pressing()){
      DriverTray = -20;
    } else if(Controller1.ButtonB.pressing()){
      if(TrayMotor.rotation(vex::rotationUnits::deg) < -10){ //Adds a stop to keep the tray from rotating backwards too far
        DriverTray = 60;
      } else {
        DriverTray = 0;
      }
    }

    if(Controller1.ButtonL1.pressing()){
      DriverArm = 100;
    } else if(Controller1.ButtonL2.pressing()){
      DriverArm = -100;
      if(TrayMotor.rotation(vex::rotationUnits::deg) > -360){
        DriverTray = -40;
      }
    } else {
      DriverArm = 0;
    }

    if(Controller1.ButtonR1.pressing()){ //intake
      DriverIntake = 100;
    } else if(Controller1.ButtonR2.pressing()){ //outtake
      DriverIntake = -100;
    } else {
      DriverIntake = 0;
    }

    driveCode(((Controller1.Axis1.value()+ Controller1.Axis3.value())/2),
      ((Controller1.Axis1.value() - Controller1.Axis3.value())/2),
      DriverArm,
      DriverTray,
      DriverIntake,
      DriverDuration);
    
      
  }
}