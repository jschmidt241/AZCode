/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       John Schmidt                                              */
/*    Created:      Thu Dec 17 2019                                           */
/*    Description:  Competition Code                                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/

#include "vex.h"

using namespace vex;

// A global instance of competition
competition Competition;

// define your global instances of motors and other devices here
vex::motor LeftFront         = vex::motor( vex::PORT3 ); //
vex::motor LeftBack          = vex::motor( vex::PORT7 ); //
vex::motor RightFront         = vex::motor( vex::PORT1 ); //
vex::motor RightBack         = vex::motor( vex::PORT10 ); //
vex::motor ArmMotor           = vex::motor( vex::PORT5 ); //
vex::motor TrayMotor         = vex::motor( vex::PORT19 ); //
vex::motor LeftIntake         = vex::motor( vex::PORT2 ); //
vex::motor RightIntake       = vex::motor( vex::PORT18 ); //

vex::controller Controller1          = vex::controller();


int DriverDuration = 20;
float DriveKp = 0.2;
float DriveKi = 0.01;
float DriveKd = 0.1;

float ArmKp = 0.2;
float ArmKi = 0;
float ArmKd = 0;

float IntakeKp = 0.2;
float IntakeKi = 0;
float IntakeKd = 0;

float TrayKp = 0.2;
float TrayKi = 0;
float TrayKd = 0;

int correct = 0;
int selected = -1;

int x;
int y;

class PID 
{
  public:
  int Target;
  int Actual;
  int LastError;
  int LastTarget;
  int Error;
  int Integral;
  int Derivative;

  PID(int a, int b, int c, int d) {
    Target = a;
    Actual = b;
    LastError = c;
    LastTarget = d;
  }
  
  void update(){

    Error = Target - Actual; //Proportional Calculations

    if(abs(Target - LastTarget) < 5 ){
      Integral = Integral + Error; //Integral Calculations
    } else {
      Integral = 0; //Decays the integral value if the target values are different
    }

    Derivative = Error - LastError; //Derivative Calculations

    LastError = Error;
    LastTarget = Target;
  }

  void setTarget(int a){
    Target = a;
  }

  void setActual(int a){
    Actual = a;
  }

};

PID LeftSide(0, 0, 0, 0);
PID RightSide(0, 0, 0, 0);
PID Arm(0, 0, 0, 0);
PID Tray(0, 0, 0, 0);
PID Intake(0, 0, 0, 0);

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void gui() {  
  Brain.Screen.clearScreen();
  Brain.Screen.clearLine();

  selected = -1;
  Brain.Screen.drawRectangle(0, 0, 240, 120, vex::color::blue);    //Blue Left
  Brain.Screen.drawRectangle(240,0,240,120,vex::color::red);       //Red Left
  Brain.Screen.drawRectangle(0, 125, 240, 120, vex::color::blue);  //Blue Right
  Brain.Screen.drawRectangle(240, 125, 240, 120, vex::color::red); //Red Right
  
  x = -20;
  y = -20;
  while(!Brain.Screen.pressing()){
    vex::task::sleep(20);
  }
  while(selected < 0){
    x = Brain.Screen.xPosition();
    y = Brain.Screen.yPosition();

    if(x < 240 && y < 125 && x > 0 && y > 0){           //Blue Left
      selected = 1;
    } else if(x < 240 && y > 125 && x > 0 && y > 0){    //Blue Right
      selected = 2;
    } else if(x > 240 && y < 125 && x > 0 && y > 0){    //Red Left
      selected = 3;
    } else if(x >240 && y > 125 && x > 0 && y > 0){     //Red Right
      selected = 4;
    }
  }

  vex::task::sleep(600);
  Brain.Screen.clearScreen();
  Brain.Screen.clearLine();
  Brain.Screen.printAt(0,20,true, "Program selected: %d", selected);
  Brain.Screen.printAt(0,50,true, "Correct?");
  Brain.Screen.drawRectangle(0,75, 240, 240, vex::color::green);
  Brain.Screen.drawRectangle(240,75, 240, 240, vex::color::red);

  while(!Brain.Screen.pressing()){
    vex::task::sleep(20);
  }
  x = Brain.Screen.xPosition();
  y = Brain.Screen.yPosition();
  vex::task::sleep(300);
  while(correct < 0){
    x = Brain.Screen.xPosition();
    y = Brain.Screen.yPosition();

    if(x < 240 && y < 240 && x > 0 && y > 75){
      correct = 1;
      break;
    } else if(x > 240 && y < 240 && y > 75){
      correct = 0;
    } 
  }
}

void pre_auton(void) {
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();

  LeftBack.setStopping(vex::brakeType::coast);
  LeftFront.setStopping(vex::brakeType::coast);
  RightFront.setStopping(vex::brakeType::coast);
  RightBack.setStopping(vex::brakeType::coast);

  ArmMotor.setStopping(vex::brakeType::hold);
  TrayMotor.setStopping(vex::brakeType::hold);
  RightIntake.setStopping(vex::brakeType::hold);
  LeftIntake.setStopping(vex::brakeType::hold);

  TrayMotor.resetRotation();

  while(correct < 1){
    correct = 0;
    selected = -1;
    gui(); 
  } 
  
  Brain.Screen.clearScreen();
  Brain.Screen.clearLine();
  Brain.Screen.printAt(5,20,true, "Program selected: %d", selected);
  
}

/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void setTargets(int Left, int Right, int Arm1, int Tray1, int Intake1){
  LeftSide.setTarget(Left);
  RightSide.setTarget(Right);
  Arm.setTarget(Arm1);
  Tray.setTarget(Tray1);
  Intake.setTarget(Intake1);
}

void driveCode(int duration){
  LeftSide.setActual((LeftFront.velocity(vex::velocityUnits::pct) + LeftBack.velocity(vex::velocityUnits::pct))/2);
  RightSide.setActual((RightFront.velocity(vex::velocityUnits::pct) + RightBack.velocity(vex::velocityUnits::pct))/2);

  LeftSide.update();
  RightSide.update();

  LeftFront.spin(vex::directionType::fwd, ((LeftSide.Target*( 0.5 )) + (LeftSide.Error * ( DriveKp )) + (LeftSide.Integral*( DriveKi )) + (LeftSide.Derivative * ( DriveKd ))), vex::velocityUnits::pct);
  LeftBack.spin(vex::directionType::fwd, ((LeftSide.Target*( 0.5 )) + (LeftSide.Error * ( DriveKp )) + (LeftSide.Integral*( DriveKi )) + (LeftSide.Derivative * ( DriveKd ))), vex::velocityUnits::pct);
  RightFront.spin(vex::directionType::fwd, ((RightSide.Target*( 0.5 )) + (RightSide.Error * ( DriveKp )) + (RightSide.Integral*( DriveKi )) + (RightSide.Derivative * ( DriveKd ))), vex::velocityUnits::pct);
  RightBack.spin(vex::directionType::fwd, ((RightSide.Target*( 0.5 )) + (RightSide.Error * ( DriveKp )) + (RightSide.Integral*( DriveKi )) + (RightSide.Derivative * ( DriveKd ))), vex::velocityUnits::pct);

  Arm.setActual(ArmMotor.velocity(vex::velocityUnits::pct));
  Tray.setActual(TrayMotor.velocity(vex::velocityUnits::pct));
  Intake.setActual((LeftIntake.velocity(vex::velocityUnits::pct) + RightIntake.velocity(vex::velocityUnits::pct))/2);

  Arm.update();
  Tray.update();
  Intake.update();

  ArmMotor.spin(vex::directionType::fwd, ((Arm.Target*( 1 )) + (Arm.Error*( ArmKp )) + (Arm.Integral*( ArmKi )) + (Arm.Derivative*( ArmKd ))), vex::velocityUnits::pct);
  TrayMotor.spin(vex::directionType::fwd, ((Tray.Target*( 1 )) + (Tray.Error*( TrayKp )) + (Tray.Integral*( TrayKi )) + (Tray.Derivative*( TrayKd ))), vex::velocityUnits::pct);
  LeftIntake.spin(vex::directionType::fwd, ((Intake.Target*( 1 )) + (Intake.Error*( IntakeKp )) + (Intake.Integral*( IntakeKi )) + (Intake.Derivative*( IntakeKd ))), vex::velocityUnits::pct);
  RightIntake.spin(vex::directionType::rev, ((Intake.Target*( 1 )) + (Intake.Error*( IntakeKp )) + (Intake.Integral*( IntakeKi )) + (Intake.Derivative*( IntakeKd ))), vex::velocityUnits::pct);

  wait(duration, msec);
}

void autonomous(void) {
  if(selected == 1){ 
    //Expand
    TrayMotor.startRotateTo(5, vex::rotationUnits::rev);
    wait(20, msec);

    setTargets(5, 5, 0, 0, -20);
    driveCode(100);

    //Blue Left
    setTargets(50, 50, 0, 0, 100);
    driveCode(1000);

    setTargets(0,0,0,0,0);
    driveCode(10);

    setTargets(-50, -20, 0, 0, 50);
    driveCode(400);

    setTargets(0, -50, 0, 0, 50);
    driveCode(280);

    setTargets(50, 50, 0, 0, 100);
    driveCode(700);

    setTargets(-10, -10, 0, 0, 0);
    driveCode(80);

    setTargets(-50, 50, 0, 0, 0);
    driveCode(200);

    setTargets(60, 60, 0, 0, 0);
    driveCode(700);

    setTargets(0, 0, 0, 40, 0);
    driveCode(1200);

    setTargets(0, 0, 0, -10, -5);
    driveCode(100);

    setTargets(-20, -20, 0, -10, -5);
    driveCode(200);

  } else if(selected == 2){
    //Expand

    //Blue Right
  } else if(selected == 3){
    //Expand

    //Red Left
  } else if(selected == 4){
    //Expand

    //Red Right
  }
}


/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void usercontrol(void) {
  
  while (1) {
    //Brain.Screen.clearLine();
    //Brain.Screen.print(TrayMotor.rotation(vex::rotationUnits::deg));

    if(Controller1.ButtonA.pressing()){
      Tray.setTarget(-50);
    } else if(Controller1.ButtonB.pressing()){
      if(TrayMotor.rotation(vex::rotationUnits::deg) < -120){ //Adds a stop to keep the tray from rotating backwards too far
        Tray.setTarget(90);
      } else {
        Tray.setTarget(0);
      }
    } else {
      Tray.setTarget(0);
    }
    if(Controller1.ButtonL1.pressing()){
      Arm.setTarget(100);
    } else if(Controller1.ButtonL2.pressing()){
      Arm.setTarget(-100);
      if(TrayMotor.rotation(vex::rotationUnits::deg) > -360){
        Tray.setTarget(-40);
      }
    } else {
      Arm.setTarget(0);
    }
    if(Controller1.ButtonR1.pressing()){ //intake
      Intake.setTarget(100);
    } else if(Controller1.ButtonR2.pressing()){ //outtake
      Intake.setTarget(-100);
    } else {
      Intake.setTarget(0);
    }
    
    RightSide.setTarget((Controller1.Axis1.value() - Controller1.Axis3.value())/2 );
    LeftSide.setTarget((Controller1.Axis1.value() + Controller1.Axis3.value())/2);

    driveCode(DriverDuration);

  }
}

int main() {
  // Callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);

  // Run the pre-autonomous function.
  pre_auton();

  // Prevent main from exiting with an infinite loop.
  while (true) {
    wait(100, msec);
  }
}