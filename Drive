/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       John Schmidt                                              */
/*    Created:      Thu Dec 17 2019                                           */
/*    Description:  Competition Code                                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/

#include "vex.h"
#include <cmath>

using namespace vex;

competition Competition;

vex::motor LeftFront         = vex::motor( vex::PORT12 ); //
vex::motor LeftBack           = vex::motor( vex::PORT4 ); //
vex::motor RightFront         = vex::motor( vex::PORT1 ); //
vex::motor RightBack         = vex::motor( vex::PORT10 ); //
vex::motor ArmMotor           = vex::motor( vex::PORT5 ); //
vex::motor TrayMotor         = vex::motor( vex::PORT19 ); //
vex::motor LeftIntake         = vex::motor( vex::PORT3 ); //
vex::motor RightIntake       = vex::motor( vex::PORT18 ); //

vex::controller Controller1          = vex::controller();   

int DriverDuration = 20;
float DriveKp = 0.04;
float DriveKi = 0;
float DriveKd = 0;

float ArmKp = 0;
float ArmKi = 0;
float ArmKd = 0;

float IntakeKp = 0.04;
float IntakeKi = 0;
float IntakeKd = 0;

float TrayKp = 0;
float TrayKi = 0;
float TrayKd = 0;

float LturnK = 1;
float RturnK = 1;
float turnK = 0.3;

class PID 
{
  public:
  int Target;
  int Actual;
  int LastError;
  int LastTarget;
  int Error;
  int Integral;
  int Derivative;

  PID(int a, int b, int c, int d) {
    Target = a;
    Actual = b;
    LastError = c;
    LastTarget = d;
  }
  
  void update(){

    Error = Target - Actual; //Proportional Calculations

    if(abs(Target - LastTarget) < 1 ){
      Integral = Integral + Error; //Integral Calculations
    } else {
      Integral = 0; //Decays the integral value if the target values are different
    }

    Derivative = Error - LastError; //Derivative Calculations

    LastError = Error;
    LastTarget = Target;
  }

  void setTarget(int a){
    Target = a;
  }

  void setActual(int a){
    Actual = a;
  }
};

PID LeftSide(0, 0, 0, 0);
PID RightSide(0, 0, 0, 0);
PID Arm(0, 0, 0, 0);
PID Tray(0, 0, 0, 0);
PID LIntake(0, 0, 0, 0);
PID RIntake(0, 0, 0, 0);

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void pre_auton(void) {
  // Initializing Robot Configuration. DO NOT REMOVE!
  LeftBack.resetPosition();
  LeftFront.resetPosition();
  RightFront.resetPosition();
  RightBack.resetPosition();

  ArmMotor.resetPosition();
  TrayMotor.resetPosition();
  RightIntake.resetPosition();
  LeftIntake.resetPosition();

  LeftBack.setStopping(vex::brakeType::coast);
  LeftFront.setStopping(vex::brakeType::coast);
  RightFront.setStopping(vex::brakeType::coast);
  RightBack.setStopping(vex::brakeType::coast);

  ArmMotor.setStopping(vex::brakeType::hold);
  TrayMotor.setStopping(vex::brakeType::hold);
  RightIntake.setStopping(vex::brakeType::hold);
  LeftIntake.setStopping(vex::brakeType::hold);
}

/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void setTargets(int Arm1, int Tray1, int LeIntake, int RiIntake){
  Arm.setTarget(Arm1);
  Tray.setTarget(Tray1);
  LIntake.setTarget(LeIntake);
  RIntake.setTarget(RiIntake);
}

float velCap;
float targetLeft = 0;
float targetRight = 0;

int errorLeft;
int errorRight;
float kp = 0.1;
float kpTurn = 0.3;
float acc = 6;
int voltageLeft = 0;
int voltageRight = 0;
int signLeft;
int signRight;
int actualLeft;
int actualRight;

int counter;
int endCounter;

void autonPID(){
  actualLeft = ((LeftFront.position(vex::rotationUnits::deg) + LeftBack.position(vex::rotationUnits::deg))/2);
  actualRight = ((RightFront.position(vex::rotationUnits::deg) + RightBack.position(vex::rotationUnits::deg))/2);

  counter = 0;

  while(counter < endCounter){
    errorLeft = targetLeft - ((LeftFront.position(vex::rotationUnits::deg) + LeftBack.position(vex::rotationUnits::deg))/2);
    errorRight = targetRight - ((RightFront.position(vex::rotationUnits::deg) + RightBack.position(vex::rotationUnits::deg))/2);

    signLeft = errorLeft / abs(errorLeft);
    signRight = errorRight / abs(errorRight);

    if(signLeft == signRight){
      voltageLeft = errorLeft * kp;
      voltageRight = errorRight * kp;
    } else{
      voltageLeft = errorLeft * kpTurn;
      voltageRight = errorRight * kpTurn;
    }

    velCap = velCap + acc;
    if(velCap > 20){
      velCap = 20;
    }

    if(abs(voltageLeft) > velCap) {
      voltageLeft = velCap * signLeft;
    }

    if(abs(voltageRight) > velCap) {
      voltageRight = velCap * signRight;
    }

    LeftFront.spin(vex::directionType::fwd, voltageLeft, vex::voltageUnits::volt);
    LeftBack.spin(vex::directionType::fwd, voltageLeft, vex::voltageUnits::volt);
    RightFront.spin(vex::directionType::fwd, voltageRight, vex::voltageUnits::volt);
    RightBack.spin(vex::directionType::fwd, voltageRight, vex::voltageUnits::volt);

    Arm.setActual(ArmMotor.velocity(vex::velocityUnits::pct));
    Tray.setActual(TrayMotor.velocity(vex::velocityUnits::pct));
    RIntake.setActual(RightIntake.velocity(vex::velocityUnits::pct));
    LIntake.setActual(LeftIntake.velocity(vex::velocityUnits::pct));

    Arm.update();
    Tray.update();
    RIntake.update();
    LIntake.update();

    ArmMotor.spin(vex::directionType::fwd, ((Arm.Target*( 1 )) + (Arm.Error*( ArmKp )) + (Arm.Integral*( ArmKi )) + (Arm.Derivative*( ArmKd ))), vex::voltageUnits::volt);
    TrayMotor.spin(vex::directionType::fwd, ((Tray.Target*( 1 )) + (Tray.Error*( TrayKp )) + (Tray.Integral*( TrayKi )) + (Tray.Derivative*( TrayKd ))), vex::voltageUnits::volt);
    LeftIntake.spin(vex::directionType::fwd, ((LIntake.Target*( 1 )) + (LIntake.Error*( IntakeKp )) + (LIntake.Integral*( IntakeKi )) + (LIntake.Derivative*( IntakeKd ))), vex::voltageUnits::volt);
    RightIntake.spin(vex::directionType::rev, ((RIntake.Target*( 1 )) + (RIntake.Error*( IntakeKp )) + (RIntake.Integral*( IntakeKi )) + (RIntake.Derivative*( IntakeKd ))), vex::voltageUnits::volt);

    counter = counter + 20;
    vex::task::sleep(20);

  }
}

void stopMotors(){
  LeftFront.stop();
  RightFront.stop();
  LeftBack.stop();
  RightBack.stop();

  RightIntake.stop();
  LeftIntake.stop();
  ArmMotor.stop();
  TrayMotor.stop();
}

void setAuton(float left, float right, int Arm1, int Tray1, int LeIntake, int RiIntake, int count){
  targetLeft = 0;
  targetRight = 0;
  LeftBack.resetPosition();
  LeftFront.resetPosition();
  RightFront.resetPosition();
  RightBack.resetPosition();

  setTargets(Arm1, Tray1, LeIntake, RiIntake);
  right = right * -1;

  left = left * 26.2; //TUNE VALUES LATER
  right = right * 26.2; //Converts values from ineches to degrees

  targetLeft = targetLeft + left;
  targetRight = targetRight + right;
  endCounter = count;
  velCap =  0;
}

void driveCode(int duration){
  LeftSide.setActual(((LeftFront.velocity(vex::velocityUnits::pct) + LeftBack.velocity(vex::velocityUnits::pct))/2) * 0.4 );
  RightSide.setActual(((RightFront.velocity(vex::velocityUnits::pct) + RightBack.velocity(vex::velocityUnits::pct))/2) * 0.4 );

  LeftSide.update();
  RightSide.update(); //Performs PID calculations and sets the new voltage

  LturnK = (LeftSide.Target - RightSide.Target) * turnK; 
  RturnK = (RightSide.Target - LeftSide.Target) * turnK;
  if(LturnK < 1){
    LturnK = 1;
  }
  if(RturnK < 1){
    RturnK = 1;
  }
  if(LturnK > 5){
    LturnK = 5;
  }
  if(RturnK > 5){
    RturnK = 5;
  }

  LeftFront.spin(vex::directionType::fwd, ((LeftSide.Target*( 0.3 * turnK )) + (LeftSide.Error * ( DriveKp )) + (LeftSide.Integral*( DriveKi )) + (LeftSide.Derivative * ( DriveKd ))), vex::voltageUnits::volt);
  LeftBack.spin(vex::directionType::fwd, ((LeftSide.Target*( 0.3 * turnK )) + (LeftSide.Error * ( DriveKp )) + (LeftSide.Integral*( DriveKi )) + (LeftSide.Derivative * ( DriveKd ))), vex::voltageUnits::volt);
  RightFront.spin(vex::directionType::fwd, ((RightSide.Target*( 0.3 * turnK )) + (RightSide.Error * ( DriveKp )) + (RightSide.Integral*( DriveKi )) + (RightSide.Derivative * ( DriveKd ))), vex::voltageUnits::volt);
  RightBack.spin(vex::directionType::fwd, ((RightSide.Target*( 0.3 * turnK )) + (RightSide.Error * ( DriveKp )) + (RightSide.Integral*( DriveKi )) + (RightSide.Derivative * ( DriveKd ))), vex::voltageUnits::volt);

  turnK = 1; //Resets the turn constant to keep it from affecting later iterations

  Brain.Screen.clearScreen();
  Brain.Screen.clearLine();
  Brain.Screen.printAt(10, 15, "Left temp: %f", LeftFront.temperature(vex::temperatureUnits::fahrenheit));  
  Brain.Screen.printAt(10, 30, "Right temp: %f", RightFront.temperature(vex::temperatureUnits::fahrenheit));

  Arm.setActual(ArmMotor.velocity(vex::velocityUnits::pct));
  Tray.setActual(TrayMotor.velocity(vex::velocityUnits::pct));
  RIntake.setActual(RightIntake.velocity(vex::velocityUnits::pct));
  LIntake.setActual(LeftIntake.velocity(vex::velocityUnits::pct));

  Arm.update();
  Tray.update();
  RIntake.update();
  LIntake.update();

  ArmMotor.spin(vex::directionType::fwd, ((Arm.Target*( 1 )) + (Arm.Error*( ArmKp )) + (Arm.Integral*( ArmKi )) + (Arm.Derivative*( ArmKd ))), vex::voltageUnits::volt);
  TrayMotor.spin(vex::directionType::fwd, ((Tray.Target*( 1 )) + (Tray.Error*( TrayKp )) + (Tray.Integral*( TrayKi )) + (Tray.Derivative*( TrayKd ))), vex::voltageUnits::volt);
  LeftIntake.spin(vex::directionType::fwd, ((LIntake.Target*( 1 )) + (LIntake.Error*( IntakeKp )) + (LIntake.Integral*( IntakeKi )) + (LIntake.Derivative*( IntakeKd ))), vex::voltageUnits::volt);
  RightIntake.spin(vex::directionType::rev, ((RIntake.Target*( 1 )) + (RIntake.Error*( IntakeKp )) + (RIntake.Integral*( IntakeKi )) + (RIntake.Derivative*( IntakeKd ))), vex::voltageUnits::volt);

  vex::task::sleep(duration);
}

void autonomous(void) {
  //deploy the bot
  
  //Drive forwarad 1/2 a tile, lifts tray
  acc = 5;
  velCap = 8;
  setAuton(5, 5, 0, -100, 0, 0, 1850);
  autonPID();
  stopMotors();
  
  RightSide.setTarget(29);
  LeftSide.setTarget(-29);
  for(int i=0; i<30; i++){
    driveCode(DriverDuration);
  }
  stopMotors();
  LeftFront.resetRotation();
  LeftBack.resetRotation();
  RightFront.resetRotation();
  RightBack.resetRotation();
  setAuton(0, 0, 0, 100, 0, 0, 2500);
  autonPID();
  stopMotors();

  //blue back auton
  
  acc = 1.1;
  velCap = 2.2;
  setAuton(7, 7, 0, 0, 100, 100, 500);
  autonPID();
  stopMotors();
  
  acc = 0.08;
  velCap = 1.8;
  setAuton(33, 30, 0, 0, 100, 100, 2750);
  autonPID();
  stopMotors();

  LeftSide.setTarget(-50);
  RightSide.setTarget(50);
  for(int i=0; i<76; i++){
    driveCode(DriverDuration);
  }

  acc = 1.1;
  velCap = 3;
  setAuton(5, 5, 0, 0, 0, 0, 400);
  autonPID();
  stopMotors();

  LeftSide.setTarget(-15); //spin to goal zone
  RightSide.setTarget(-15);
  driveCode(DriverDuration);
  vex::task::sleep(1020);
  LeftSide.setTarget(0);
  RightSide.setTarget(0);
  stopMotors();

  acc = 0.5;
  velCap = 1.6;
  setAuton(4, 10, 0, 0, 0, 0, 800);
  autonPID();
  stopMotors();

  setAuton(0, 0, 0, 0, -4, -4, 600);
  autonPID();
  stopMotors();

  setAuton(6, 6, 0, -9, 0, 0, 1450);
  autonPID();
  stopMotors();

  setAuton(0, 0, 0, -5, 0, 0, 500);
  autonPID();
  stopMotors();

  acc = 0.3;
  velCap = 2;
  setAuton(30, 30, 0, -5, -5, -5, 1500);
  autonPID();
  stopMotors();

  acc = 0.1;
  velCap = 2;
  setAuton(-15, -15, 0, 5, -15, -15, 800);
  stopMotors();

  RightSide.setTarget(15);
  LeftSide.setTarget(-15);
  driveCode(DriverDuration);
  vex::task::sleep(1000);
  stopMotors();
}



/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void usercontrol(void) {
  
  while(1){
    if(Controller1.ButtonA.pressing()){
      Tray.setTarget(-18);
    } else if(Controller1.ButtonB.pressing()){
      //if(TrayMotor.rotation(vex::rotationUnits::deg) < -120){ //Adds a stop to keep the tray from rotating backwards too far
      Tray.setTarget(90);
      //} else {
      //  Tray.setTarget(0);
      //}
    } else {
      Tray.setTarget(0);
    }
    if(Controller1.ButtonLeft.pressing()){
      Tray.setTarget(25);
    }

    if(Controller1.ButtonL1.pressing()){
      Arm.setTarget(100);
    } else if(Controller1.ButtonL2.pressing()){
      Arm.setTarget(-100);
      //if(TrayMotor.rotation(vex::rotationUnits::deg) > -450){ //Moves tray up with the arm to avoid catching on each other
      TrayMotor.startRotateFor(5, vex::rotationUnits::rev, 60, vex::velocityUnits::pct);
      //}
    } else {
      Arm.setTarget(0);
    }

    if(Controller1.ButtonR1.pressing()){ //intake
      RIntake.setTarget(100);
      LIntake.setTarget(100);
    } else if(Controller1.ButtonR2.pressing()){ //outtake
      RIntake.setTarget(-100);
      LIntake.setTarget(-100);
    } else {
      RIntake.setTarget(0);
      LIntake.setTarget(0);
    }
    
    RightSide.setTarget((Controller1.Axis1.value() - Controller1.Axis3.value())/2);
    LeftSide.setTarget((Controller1.Axis1.value() + Controller1.Axis3.value())/2);

    if(Controller1.ButtonDown.pressing()){
      RIntake.setTarget(-10);
      LIntake.setTarget(-10);
      RightSide.setTarget(15);
      LeftSide.setTarget(-15);
      Tray.setTarget(20);
    }

    if(Controller1.ButtonY.pressing()){
      /**
      acc = 5;
      velCap = 8;
      setAuton(5, 5, 0, -100, 0, 0, 1850);
      autonPID();
      stopMotors();
  
      RightSide.setTarget(29);
      LeftSide.setTarget(-29);
      for(int i=0; i<30; i++){
        driveCode(DriverDuration);
      }
      stopMotors();
      LeftFront.resetRotation();
      LeftBack.resetRotation();
      RightFront.resetRotation();
      RightBack.resetRotation();
      setAuton(0, 0, 0, 100, 0, 0, 2500);
      autonPID();
      stopMotors();
      **/
    }

    if(LeftFront.temperature(vex::temperatureUnits::fahrenheit) > 120 || RightFront.temperature(vex::temperatureUnits::fahrenheit) > 120){
      Controller1.rumble("-");
    }
    

    driveCode(DriverDuration);
    
  }
}

int main() {
  // Callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);

  // Run the pre-autonomous function.
  pre_auton();

  // Prevent main from exiting with an infinite loop.
  while (true) {
    wait(100, msec);
  }
}
