/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       C:\Users\StudentB                                         */
/*    Created:      Mon Jan 27 2020                                           */
/*    Description:  V5 project                                                */
/*                                                                            */
/*----------------------------------------------------------------------------*/

#include "vex.h"
#include <cmath>

using namespace vex;

//Constant Definitions
int DriverDuration = 20;
float DriveKp = 0.175;
float DriveKi = 0;
float DriveKd = 0;

float ArmKp = 0.1;
float ArmKi = 0;
float ArmKd = 0;

float IntakeKp = 0.04;
float IntakeKi = 0;
float IntakeKd = 0;

float TrayKp = 0.06;
float TrayKi = 0.02;
float TrayKd = 0.01;

float LturnK = 1;
float RturnK = 1;
float turnK = 0.1;

bool LED_On;
bool rumbling;
bool trayLoop = false;
bool turning = false;

double timerNum;

class PID
{
  public:
  int Target;
  int Actual;
  int LastError;
  int LastTarget;
  int Error;
  int Integral;
  int Derivative;

  bool auton;
  float velCap;
  float acc;
  float base;
  int sign;

  PID(int a, int b, int c, int d, bool e) {
    Target = a;
    Actual = b;
    LastError = c;
    LastTarget = d;
    auton = e;
  }

  void update(){
    Error = Target - Actual; //Proportional calculations

    if(abs(Error) < 20 ){ 
      Integral = 0; //Integral Calculations
    } else {
      Integral = Integral + Error;
    }

    Derivative = Error - LastError; //Derivative Calculations

    LastError = Error;
    LastTarget = Target;

    if(auton){
      acc = acc + base;

      if(acc > velCap){
        acc = velCap;
      }
      //ADD if over .75, subtract acc instead of add to velBottom
      if(std::abs(Error) > acc){
        Error = acc * sign;
      }
    }    
  }

  void setTarget(int a){
    Target = a;
  }

  void setActual(int a){
    Actual = a;
  }

  void setAuton(bool a){
    auton = a;
  }

  void setVelCap(float a){
    velCap = a;
  }

  void setAcc(float a){
    acc = a;
  }

  void setBase(float a){
    base = a;
  }

  void setSign(int a){
    sign = a;
  }

  int getTarget(){
    return Target;
  }
};

PID LeftSide(0, 0, 0, 0, true);
PID RightSide(0, 0, 0, 0, true);
PID Arm(0, 0, 0, 0, false);
PID Tray(0, 0, 0, 0, false);
PID LIntake(0, 0, 0, 0, false);
PID RIntake(0, 0, 0, 0, false);

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
int selected;
bool correct;
int autonColor; //blue is negative, red is positive

void auton_selector(void){
  selected = -1;
  correct = false;
  autonColor = 0;
  while(autonColor == 0){
    Brain.Screen.clearLine();
    Brain.Screen.printAt(10, 15, "Blue or Red? (Left is b, right is r)");
    if(Controller1.ButtonLeft.pressing()){
      autonColor = -1;
      vex::task::sleep(100);
    } else if(Controller1.ButtonRight.pressing()){
      autonColor = 1;
      vex::task::sleep(100);
    } else if(Controller1.ButtonDown.pressing()){
      vex::task::sleep(100);
      return;
    }
    vex::task::sleep(20);
  }
  while(selected < 0){
    Brain.Screen.clearLine();
    Brain.Screen.printAt(10,15, "Protected or unprotected (Left is p, right is u");
    if(Controller1.ButtonLeft.pressing()){
      selected = 1;
      vex::task::sleep(100);
    } else if(Controller1.ButtonRight.pressing()){
      selected = 2;
      vex::task::sleep(100);
    }
    vex::task::sleep(20);
  }
  Brain.Screen.clearLine();
  if(autonColor == -1 && selected == 1){
    Brain.Screen.printAt(10, 15, "You chose Blue protected. Correct?");
  } else if(autonColor == -1 && selected == 2){
    Brain.Screen.printAt(10, 15, "You chose Blue unprotected. Correct?");
  } else if(autonColor == 1 && selected == 1){
    Brain.Screen.printAt(10, 15, "You chose Red protected. Correct?");
  } else if(autonColor == 1 && selected == 2){
    Brain.Screen.printAt(10, 15, "You chose Red unprotected. Correct?");
  }
  while(!correct){
    if(Controller1.ButtonLeft.pressing()){
      auton_selector();
    } else if(Controller1.ButtonRight.pressing()){
      correct = !correct;
    }
    vex::task::sleep(100);
  }
}

void pre_auton(void) {
  //auton_selector();
  gyroscope.startCalibration();
  
  LeftBack.resetPosition();
  LeftFront.resetPosition();
  RightFront.resetPosition();
  RightBack.resetPosition();

  ArmMotor.resetPosition();
  TrayMotor.resetPosition();
  RightIntake.resetPosition();
  LeftIntake.resetPosition();

  LeftBack.setStopping(vex::brakeType::coast);
  LeftFront.setStopping(vex::brakeType::coast);
  RightFront.setStopping(vex::brakeType::coast);
  RightBack.setStopping(vex::brakeType::coast);

  ArmMotor.setStopping(vex::brakeType::hold);
  TrayMotor.setStopping(vex::brakeType::hold);
  RightIntake.setStopping(vex::brakeType::coast);
  LeftIntake.setStopping(vex::brakeType::coast);

  while(gyroscope.isCalibrating()){
    Brain.Screen.clearScreen();
    Brain.Screen.clearLine();
    Brain.Screen.printAt(10, 15, "Gyro still calibrating");
    vex::task::sleep(20);
  }

  Brain.Screen.clearScreen();
  Brain.Screen.clearLine();
  Brain.Screen.printAt(10, 15, "Gyro calibrated.");

}

/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void setTargets(int Arm1, int Tray1, int LeIntake, int RiIntake){
  Arm.setTarget(Arm1);
  Tray.setTarget(Tray1);
  LIntake.setTarget(LeIntake);
  RIntake.setTarget(RiIntake);
}

int counter;
int endCounter;

void autonPID(){
  counter = 0;

  while(counter < endCounter){

    if(!turning){
      LeftSide.setActual((LeftFront.position(vex::rotationUnits::deg) + LeftBack.position(vex::rotationUnits::deg))/2);
      RightSide.setActual((RightFront.position(vex::rotationUnits::deg) + RightBack.position(vex::rotationUnits::deg))/2);

      LeftSide.update();
      RightSide.update();

      LeftFront.spin(vex::directionType::fwd, LeftSide.Error, vex::voltageUnits::volt);
      LeftBack.spin(vex::directionType::fwd, LeftSide.Error, vex::voltageUnits::volt);
      RightFront.spin(vex::directionType::fwd, RightSide.Error, vex::voltageUnits::volt);
      RightBack.spin(vex::directionType::fwd, RightSide.Error, vex::voltageUnits::volt);

    } else if(turning){
      LeftSide.setActual(gyroscope.rotation(vex::rotationUnits::deg) * 0.978);      //Sets PID actual values to gyroscope value, tuned by the constant after testing
      RightSide.setActual(gyroscope.rotation(vex::rotationUnits::deg) * -1 * 0.978);

      LeftSide.update();
      RightSide.update();

      Brain.Screen.clearScreen();
      Brain.Screen.clearLine();
      Brain.Screen.printAt(10, 15, "Gyro Left: %f", gyroscope.rotation(vex::rotationUnits::deg));
      Brain.Screen.printAt(10, 30, "Gyro Right: %f", gyroscope.rotation(vex::rotationUnits::deg) * -1);
      Brain.Screen.printAt(10, 45, "Left Error: %d", LeftSide.Error);
      Brain.Screen.printAt(10, 60, "Right Error: %d", RightSide.Error);

      LeftFront.spin(vex::directionType::fwd, LeftSide.Error * 0.1, vex::voltageUnits::volt);
      LeftBack.spin(vex::directionType::fwd, LeftSide.Error * 0.1, vex::voltageUnits::volt);
      RightFront.spin(vex::directionType::fwd, RightSide.Error * 0.1, vex::voltageUnits::volt);
      RightBack.spin(vex::directionType::fwd, RightSide.Error * 0.1, vex::voltageUnits::volt);
    }

    Arm.setActual(ArmMotor.velocity(vex::velocityUnits::pct));
    RIntake.setActual(RightIntake.velocity(vex::velocityUnits::pct));
    LIntake.setActual(LeftIntake.velocity(vex::velocityUnits::pct));

    Arm.update();
    RIntake.update();
    LIntake.update();

    ArmMotor.spin(vex::directionType::fwd, ((Arm.Target*( 1 )) + (Arm.Error*( ArmKp )) + (Arm.Integral*( ArmKi )) + (Arm.Derivative*( ArmKd ))), vex::voltageUnits::volt);
    LeftIntake.spin(vex::directionType::fwd, ((LIntake.Target*( 1 )) + (LIntake.Error*( IntakeKp )) + (LIntake.Integral*( IntakeKi )) + (LIntake.Derivative*( IntakeKd ))), vex::voltageUnits::volt);
    RightIntake.spin(vex::directionType::rev, ((RIntake.Target*( 1 )) + (RIntake.Error*( IntakeKp )) + (RIntake.Integral*( IntakeKi )) + (RIntake.Derivative*( IntakeKd ))), vex::voltageUnits::volt);

    if(!trayLoop){
      Tray.setActual(TrayMotor.velocity(vex::velocityUnits::pct));
      Tray.update();
      TrayMotor.spin(vex::directionType::fwd, ((Tray.Target*( 1 )) + (Tray.Error*( TrayKp )) + (Tray.Integral*( TrayKi )) + (Tray.Derivative*( TrayKd ))), vex::voltageUnits::volt);
    } else if(trayLoop){
      Tray.setActual(TrayMotor.position(vex::rotationUnits::deg));
      Tray.update();
      TrayMotor.spin(vex::directionType::fwd, (Tray.Error*( TrayKp )) + (Tray.Integral*( TrayKi )) + (Tray.Derivative*( TrayKd )), vex::voltageUnits::volt);
  }
    counter = counter + 20;
    vex::task::sleep(20);
  }
}



void setAuton(float left, float right, float velCap, float acc, float base, int Arm1, int Tray1, int LeIntake, int RiIntake, int count){
  LeftBack.resetPosition();
  LeftFront.resetPosition();
  RightFront.resetPosition();
  RightBack.resetPosition();

  //Sets the PID objects with inputted values
  LeftSide.setVelCap(velCap);
  RightSide.setVelCap(velCap);
  LeftSide.setAcc(acc);
  RightSide.setAcc(acc);
  LeftSide.setBase(base);
  RightSide.setBase(base);

  setTargets(Arm1, Tray1, LeIntake, RiIntake);

  if(!turning){
    left = left * 26.2;    //Changes degrees to inches using circumference of wheels (not 100% accurate)
    right = right * 26.2;
  }
  
  if(left < 0){
    LeftSide.setSign(-1); //Sets the sign of the PID object so that the slew rate doesn't make the value constantly positive
  } else {
    LeftSide.setSign(1);
  }
  if(right < 0){
    RightSide.setSign(-1);
  } else {
    RightSide.setSign(1);
  }

  LeftSide.setTarget(left);
  RightSide.setTarget(right);
  endCounter = count; //time allotted for each motor to reach its target value
}

void stopMotors(){
  LeftFront.stop();
  RightFront.stop();
  LeftBack.stop();
  RightBack.stop();

  ArmMotor.stop();
  TrayMotor.stop();
  LeftIntake.stop();
  RightIntake.stop();
}

void driveCode( int duration ){

  LeftSide.setActual(((LeftFront.velocity(vex::velocityUnits::pct) + LeftBack.velocity(vex::velocityUnits::pct))/2) * 0.4 );
  RightSide.setActual(((RightFront.velocity(vex::velocityUnits::pct) + RightBack.velocity(vex::velocityUnits::pct))/2) * 0.4 );

  LeftSide.update();
  RightSide.update(); //Performs PID calculations and sets the new voltage

  LturnK = (LeftSide.Target - RightSide.Target) * turnK; 
  RturnK = (RightSide.Target - LeftSide.Target) * turnK;
  if(LturnK < 1){
    LturnK = 1;
  }
  if(RturnK < 1){
    RturnK = 1;
  }
  if(LturnK > 5){
    LturnK = 5;
  }
  if(RturnK > 5){
    RturnK = 5;
  }

  LeftFront.spin(vex::directionType::fwd, ((LeftSide.Target*( 0.2  )) + (LeftSide.Error * ( DriveKp )) + (LeftSide.Integral*( DriveKi )) + (LeftSide.Derivative * ( DriveKd ))), vex::voltageUnits::volt);
  LeftBack.spin(vex::directionType::fwd, ((LeftSide.Target*( 0.2  )) + (LeftSide.Error * ( DriveKp )) + (LeftSide.Integral*( DriveKi )) + (LeftSide.Derivative * ( DriveKd ))), vex::voltageUnits::volt);
  RightFront.spin(vex::directionType::fwd, ((RightSide.Target*( 0.2  )) + (RightSide.Error * ( DriveKp )) + (RightSide.Integral*( DriveKi )) + (RightSide.Derivative * ( DriveKd ))), vex::voltageUnits::volt);
  RightBack.spin(vex::directionType::fwd, ((RightSide.Target*( 0.2  )) + (RightSide.Error * ( DriveKp )) + (RightSide.Integral*( DriveKi )) + (RightSide.Derivative * ( DriveKd ))), vex::voltageUnits::volt);

  turnK = 1; //Resets the turn constant to keep it from affecting later iterations

  Brain.Screen.clearScreen();
  Brain.Screen.clearLine();
  Brain.Screen.printAt(10, 15, "Left temp: %f", LeftFront.temperature(vex::temperatureUnits::fahrenheit));  
  Brain.Screen.printAt(10, 30, "Right temp: %f", RightFront.temperature(vex::temperatureUnits::fahrenheit));
  Brain.Screen.printAt(10, 60, "Arm Position: %f", TrayMotor.position(vex::rotationUnits::deg));
  Brain.Screen.printAt(10, 75, "Gyro degrees: %f", gyroscope.value(vex::rotationUnits::deg));
  Brain.Screen.printAt(10, 90, "Gyro analog: %d", gyroscope.value(vex::analogUnits::range10bit));

  Arm.setActual(ArmMotor.velocity(vex::velocityUnits::pct));
  RIntake.setActual(RightIntake.velocity(vex::velocityUnits::pct));
  LIntake.setActual(LeftIntake.velocity(vex::velocityUnits::pct));

  Arm.update();
  RIntake.update();
  LIntake.update();

  ArmMotor.spin(vex::directionType::fwd, ((Arm.Target*( 1 )) + (Arm.Error*( ArmKp )) + (Arm.Integral*( ArmKi )) + (Arm.Derivative*( ArmKd ))), vex::voltageUnits::volt);
  LeftIntake.spin(vex::directionType::fwd, ((LIntake.Target*( 1 )) + (LIntake.Error*( IntakeKp )) + (LIntake.Integral*( IntakeKi )) + (LIntake.Derivative*( IntakeKd ))), vex::voltageUnits::volt);
  RightIntake.spin(vex::directionType::rev, ((RIntake.Target*( 1 )) + (RIntake.Error*( IntakeKp )) + (RIntake.Integral*( IntakeKi )) + (RIntake.Derivative*( IntakeKd ))), vex::voltageUnits::volt);
  if(!trayLoop){
    Tray.setActual(TrayMotor.velocity(vex::velocityUnits::pct));
    Tray.update();
    TrayMotor.spin(vex::directionType::fwd, ((Tray.Target*( 1 )) + (Tray.Error*( TrayKp ))), vex::voltageUnits::volt);
  } else if(trayLoop){
    Tray.setActual(TrayMotor.position(vex::rotationUnits::deg));
    Tray.update();
    TrayMotor.spin(vex::directionType::fwd, (Tray.Error*( TrayKp )) + (Tray.Integral*( TrayKi )) + (Tray.Derivative*( TrayKd )), vex::voltageUnits::volt);
  }
  
  vex::task::sleep(duration);
}

void autonomous( void ) {
  
  Brain.resetTimer();
  LeftSide.setAuton(true);
  RightSide.setAuton(true);

  setAuton(0, 0, 0, 0, 0, 0, 100, -100, -100, 700);
  autonPID();
  stopMotors();

  setAuton(0, 0, 0, 0, 0, 0, -100, 0, 0, 700);
  autonPID();
  stopMotors();

  //Collect first two cubes and finish deploy
  setAuton(30, 30, 4, 0.2, 1, 0, 0, 80, 80, 2380);
  autonPID();
  stopMotors();

  vex::task::sleep(200);

  turning = true;
  LeftSide.setAuton(false);
  RightSide.setAuton(false);
  setAuton(54, -54, 0, 0, 0, 0, 0, 0, 0, 490);
  autonPID();
  stopMotors();
  turning = false;
  LeftSide.setAuton(true);
  RightSide.setAuton(true);

  //Backwards to wall
  setAuton(-24, -24, 5.5, 0.5, 1, 0, 0, 30, 30, 2100);
  autonPID();
  stopMotors();

  turning = true;
  LeftSide.setAuton(false);
  RightSide.setAuton(false);
  setAuton(-9, 9, 0, 0, 0, 0, 0, 0, 0, 475);
  autonPID();
  stopMotors();
  turning = false;
  LeftSide.setAuton(true);
  RightSide.setAuton(true);
  
  //Collect four cubes
  setAuton(25, 25, 4.5, 0.2, 1, 0, 0, 100, 100, 1900);
  autonPID();
  stopMotors();

  //Rotate to goal
  turning = true;
  LeftSide.setAuton(false);
  RightSide.setAuton(false);
  setAuton(-128, 128, 5, 0.2, 1, 0, 0, 80, 80, 875);
  autonPID();
  stopMotors();
  turning = false;
  LeftSide.setAuton(true);
  RightSide.setAuton(true);

  //Drive to goal
  setAuton(20, 20, 8, 0.6, 1.2, 0, 0, 0, 0, 530);
  autonPID();
  stopMotors();

  vex::task::sleep(45);

  //Outtake the cubes before stacking
  setAuton(0, 0, 0, 0, 0, 0, 0, -38, -38, 530);
  autonPID();
  stopMotors();

  //Stack
  vex::task::sleep(30);
  trayLoop = true;
  setAuton(3, 3, 1, 0.1, 0.1, 0, 2375, 0, 0, 2730);
  autonPID();
  stopMotors(); 
  trayLoop = false;

  //Push stack forward
  setAuton(6, 6, 1, 0.5, 0.5, 0, 0, 0, 0, 300);
  //autonPID();
  stopMotors();

  //Back away
  setAuton(-20, -20, 6, 0.1, 0.5, 0, -10, -15, -15, 300);
  autonPID();
  stopMotors();

  Brain.Screen.clearScreen();
  Brain.Screen.printAt(10, 25, "Time elapsed: %f", Brain.timer(vex::timeUnits::msec));

}
/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void setTimer( void ){
  timerNum = Brain.timer(vex::timeUnits::msec);
}

void usercontrol(void) {
  
  TrayMotor.setStopping(vex::brakeType::hold);
  LeftSide.setAuton(false);
  RightSide.setAuton(false);

  Controller1.ButtonDown.pressed( setTimer );

  while(1){
    if(Controller1.ButtonA.pressing()){
      trayLoop = false;
      Tray.setTarget(20);
    } else if(Controller1.ButtonY.pressing()){
      trayLoop = false;
      Tray.setTarget(-20);
    } else if (Controller1.ButtonLeft.pressing()){
      trayLoop = true;
      Tray.setTarget(2280); //CHANGE THIS - TRAY VALUE AT TOP
    } else {
      trayLoop = false;
      Tray.setTarget(0);
    }

    if(Controller1.ButtonL1.pressing()){
      Arm.setTarget(100);
    } else if(Controller1.ButtonL2.pressing()){
      Arm.setTarget(-100);
    } else {
      Arm.setTarget(0);
    }

    if(Controller1.ButtonR1.pressing()){ //intake
      RIntake.setTarget(100);
      LIntake.setTarget(100);
    } else if(Controller1.ButtonR2.pressing()){ //outtake
      RIntake.setTarget(-100);
      LIntake.setTarget(-100);
    } else {
      RIntake.setTarget(0);
      LIntake.setTarget(0);
    }
    
    RightSide.setTarget((Controller1.Axis3.value() - Controller1.Axis1.value())/2);
    LeftSide.setTarget((Controller1.Axis1.value() + Controller1.Axis3.value())/2);

    if(Controller1.ButtonDown.pressing()){

      if(std::abs(Brain.timer(vex::timeUnits::msec) - timerNum) < 750){
        Tray.setTarget(-25);
      } else {
        RIntake.setTarget(-10);
        LIntake.setTarget(-10);
        RightSide.setTarget(-15);
        LeftSide.setTarget(-15);
      }
    }

    if(Controller1.ButtonUp.pressing()){
      LED_On = !LED_On;
      if(LED_On){
        //LED.state(100, vex::percentUnits::pct);
        vex::task::sleep(200);
      } else{
        //LED.state(0, vex::percentUnits::pct);
        vex::task::sleep(200);
      }
    }

    if(Controller1.ButtonX.pressing()){
      rumbling = !rumbling;
      vex::task::sleep(200);
    }

    if((LeftFront.temperature(vex::temperatureUnits::fahrenheit) > 115 || RightFront.temperature(vex::temperatureUnits::fahrenheit) > 115 || LeftBack.temperature(vex::temperatureUnits::fahrenheit) > 115 || RightBack.temperature(vex::temperatureUnits::fahrenheit) > 115 ) && rumbling){
      Controller1.rumble("-     ");
    }

    driveCode(DriverDuration);
    
  }
}

int main() {

  // Callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);

  // Run the pre-autonomous function.
  pre_auton();

  // Prevent main from exiting with an infinite loop.
  while (true) {
    wait(100, msec);
  }
}